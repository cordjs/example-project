// Generated by CoffeeScript 1.3.3
var copyFile, countFiles, exec, exists, fs, fsExtra, hidden, outputPath, path, printLine, printWarn, publicDir, removeSource, sources, spawn, syncFile, syncFiles, targetDir, timeLog, unwatchDir, util, wait, walk, watchDir, watchFile, _ref;

fs = require('fs');

util = require('util');

fsExtra = require('fs.extra');

path = require('path');

walk = require('walk');

_ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

publicDir = 'public';

targetDir = 'target';

sources = [];

countFiles = null;

exports.run = function() {
  return fsExtra.rmrf(targetDir, function(err) {
    return exec("mkdir -p " + (path.join(targetDir)), function() {
      countFiles = 0;
      return fs.realpath(publicDir, function(err, source) {
        return syncFiles(source, path.normalize(source), function() {
          exec("coffee -bc -o " + targetDir + " " + publicDir);
          exec("sass --update " + publicDir + ":" + targetDir);
          return timeLog("Synchronized " + countFiles + " files");
        });
      });
    });
  });
};

syncFiles = function(source, base, callback) {
  return fs.stat(source, function(err, stats) {
    var walker;
    if (stats.isFile()) {
      return syncFile(source, base);
    }
    walker = walk.walk(source);
    walker.on('directory', function(root, stat, next) {
      source = path.join(root, stat.name);
      if (hidden(source)) {
        return next();
      }
      watchDir(source, base);
      return next();
    });
    walker.on('file', function(root, stat, next) {
      source = path.join(root, stat.name);
      if (hidden(source)) {
        return next();
      }
      return syncFile(source, base, function() {
        countFiles++;
        return next();
      });
    });
    return walker.on('end', function() {
      return typeof callback === "function" ? callback() : void 0;
    });
  });
};

syncFile = function(source, base, callback, onlyWatch) {
  if (onlyWatch == null) {
    onlyWatch = false;
  }
  if (!onlyWatch) {
    sources.push(source);
  }
  if (!onlyWatch) {
    watchFile(source, base);
  }
  switch (path.extname(source)) {
    case ".coffee":
    case ".scss":
    case ".sass":
      return callback();
    default:
      return copyFile(source, base, function(err) {
        return typeof callback === "function" ? callback() : void 0;
      });
  }
};

copyFile = function(source, base, callback) {
  var copyHelper, fileDir, filePath;
  filePath = outputPath(source, base);
  fileDir = path.dirname(filePath);
  copyHelper = function() {
    return fs.stat(source, function(err, stat) {
      if (err) {
        if (typeof callback === "function") {
          callback(err);
        }
      }
      return util.pump(fs.createReadStream(source), fs.createWriteStream(filePath), function(err) {
        if (err) {
          if (typeof callback === "function") {
            callback(err);
          }
        }
        return fs.utimes(filePath, stat.atime, stat.mtime, callback);
      });
    });
  };
  return exists(fileDir, function(itExists) {
    if (itExists) {
      return copyHelper();
    } else {
      return exec("mkdir -p " + fileDir, copyHelper);
    }
  });
};

watchFile = function(source, base) {
  var prevStats, rewatch, sync, syncTimeout, watchErr, watcher;
  prevStats = null;
  syncTimeout = null;
  watchErr = function(e) {
    if (e.code === 'ENOENT') {
      if (sources.indexOf(source) === -1) {
        return;
      }
      try {
        rewatch();
        return sync();
      } catch (e) {
        return removeSource(source, base, true);
      }
    } else {
      throw e;
    }
  };
  sync = function() {
    clearTimeout(syncTimeout);
    return syncTimeout = wait(25, function() {
      return fs.stat(source, function(err, stats) {
        if (err) {
          return watchErr(err);
        }
        if (prevStats && stats.size === prevStats.size && stats.mtime.getTime() === prevStats.mtime.getTime()) {
          return rewatch();
        }
        prevStats = stats;
        return syncFile(source, base, function() {
          timeLog("update file " + source);
          return rewatch();
        }, true);
      });
    });
  };
  try {
    watcher = fs.watch(source, sync);
  } catch (e) {
    watchErr(e);
  }
  return rewatch = function() {
    if (watcher != null) {
      watcher.close();
    }
    return watcher = fs.watch(source, sync);
  };
};

watchDir = function(source, base) {
  var readdirTimeout, watcher;
  readdirTimeout = null;
  try {
    return watcher = fs.watch(source, function() {
      console.log('watcher: ', source);
      clearTimeout(readdirTimeout);
      return readdirTimeout = wait(25, function() {
        return fs.readdir(source, function(err, files) {
          var file, _i, _len, _results;
          if (err) {
            console.log('erro: ', err, ', cource: ', source);
            if (err.code !== 'ENOENT') {
              throw err;
            }
            watcher.close();
            console.log('removeDir:', source);
            return unwatchDir(source, base);
          }
          _results = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            file = path.join(source, file);
            if (sources.some(function(s) {
              return s.indexOf(file) >= 0;
            })) {
              continue;
            }
            console.log('syncFiles: ', file, ', base: ', base);
            sources.push(file);
            _results.push(syncFiles(file, base));
          }
          return _results;
        });
      });
    });
  } catch (e) {
    if (e.code !== 'ENOENT') {
      throw e;
    }
  }
};

unwatchDir = function(source, base) {
  var file, prevSources, toRemove, _i, _len;
  prevSources = sources.slice(0);
  toRemove = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      file = sources[_i];
      if (file.indexOf(source) >= 0) {
        _results.push(file);
      }
    }
    return _results;
  })();
  for (_i = 0, _len = toRemove.length; _i < _len; _i++) {
    file = toRemove[_i];
    removeSource(file, base, true);
  }
  if (!sources.some(function(s, i) {
    return prevSources[i] !== s;
  })) {

  }
};

removeSource = function(source, base, remove) {
  var index, outPath;
  index = sources.indexOf(source);
  sources.splice(index, 1);
  if (remove) {
    outPath = outputPath(source, base);
    return exists(outPath, function(itExists) {
      if (itExists) {
        return fs.unlink(outPath, function(err) {
          if (err && err.code !== 'ENOENT') {
            throw err;
          }
          return timeLog("removed " + source);
        });
      }
    });
  }
};

outputPath = function(source, base) {
  var baseDir, dir, filename, srcDir;
  filename = path.basename(source);
  srcDir = path.dirname(source);
  baseDir = base === '.' ? srcDir : srcDir.substring(base.length);
  dir = path.join(targetDir, baseDir);
  return path.join(dir, filename);
};

wait = function(milliseconds, func) {
  return setTimeout(func, milliseconds);
};

exists = fs.exists || path.exists;

hidden = function(file) {
  return /\/\.|~$/.test(file) || /^\.|~$/.test(file);
};

timeLog = function(message) {
  return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
};

printLine = function(line) {
  return process.stdout.write(line + '\n');
};

printWarn = function(line) {
  return process.stderr.write(line + '\n');
};
